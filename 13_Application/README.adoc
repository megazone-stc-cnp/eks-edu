= 13. 어플리케이션
// Settings:
:experimental:
:icons: font
:sectnums:
// :!sectids:
// Github?
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]
// No Github?
ifndef::env-github[]
:toc: left
:toclevels: 4
:source-highlighter: highlight.js
endif::[]
:revealjsdir: https://cdn.jsdelivr.net/npm/reveal.js
:revealjs_showSlideNumber: all
:revealjs_hash: true
// Presentation 변환 참고용
// - https://asciidoc-slides.8vi.cat/
// - https://zenika.github.io/adoc-presentation-model/reveal-my-asciidoc.html

== 목표
- Kubernetes의 Object에 대해서 학습
- Deployment 전략 ( Blue/Green, Canary, Rolling ) 에 대해서 학습
- PDB에 대해서 학습
- Helm 생성 하는 방법에 대해서 학습
- ArgoCD에 대해서 학습

== 사전 조건

1. link:00_Setup/[0. 교육 환경 구성하기]를 이용해 기본 실습 환경 생성이 되어 있어야 합니다.
2. link:00_Setup/[0. 교육 환경 구성하기]를 이용해 생성된 `code-server`에 접속한 상태여야 합니다.
3. link:13_Application/[13. Application 배포 - 기본]에 00_pre_setup/01_install.sh 를 실행하여 EBS CSI DRiver/EFS CSI Driver Addon이 같이 설치된 EKS를 구축합니다.
[source,shell]
----
cd ~/environment/eks-edu/13_Application/00_pre_setup
sh 01_install.sh
----

== 이론

=== Kubernetes의 Object란
쿠버네티스 오브젝트는 *하나의 의도를 담은 레코드* 이다.

오브젝트를 생성하게 되면 쿠버네티스 시스템은 그 오브젝트 생성을 보장하기 위해 지속적으로 작동할 것이다.

==== 관리 기법
- 명령형 커맨드
+
[source,shell]
----
kubectl create deployment nginx --image nginx
----

- 명령형 오브젝트 구성
+
[source,shell]
----
kubectl create -f nginx.yaml
----

=== Object 종류

==== 명령어
[source,shell]
----
# namespace 목록
kubectl api-resources
----

==== namespace
쿠버네티스에서 네임스페이스는 단일 클러스터 내에서의 리소스 그룹 격리 메커니즘을 제공한다.

네임스페이스는 여러 개의 팀이나, 프로젝트에 걸쳐서 많은 사용자가 있는 환경에서 사용하도록 만들어 졌다.

리소스 이름은 네임스페이스 내에서 유일해야 하며, 네임스페이스 간에는 유일할 필요는 없다.

- 네임스페이스 기반 오브젝트 : Deployment, Service 등등
- 클러스터 범위 오브젝트 : StorageClass, Node, PersistentVolume

==== 조회
[source,shell]
----
# namespace 목록
kubectl get namespace

# default namespace 설정
kubectl config set-context --current --namespace=<insert-namespace-name-here>

# 확인하기
kubectl config view --minify | grep namespace:

----
==== 파이널라이저
파이널라이저는 쿠버네티스가 오브젝트를 완전히 삭제하기 이전, 삭제 표시를 위해 특정 조건이 충족될 때까지 대기하도록 알려주기 위한 네이스페이스에 속한 키이다.

리소스를 삭제하려 할 때는 삭제 요청을 처리하는 API 서버가 ``finalizers`` 필드의 값을 인식하고 다음을 수행
- 삭제를 시작한 시간과 함께 ``metadata.deletionTimestamp`` 필드를 추가하도록 오브젝트를 수정한다.
- 오브젝트의 ``metadata.finalizers`` 필드가 비워질 때까지 오브젝트가 제거되지 않도록 한다.

파이널라이저의 일반적인 예로 ``퍼시스턴트 볼륨`` 오브젝트가 실수로 삭제되는 것을 방지하는 ``kubernetes.io/pv-protection`` 가 있다.
파드가 ``퍼시스턴트 볼륨`` 오브젝트를 사용 중일 때 쿠버네티스틑 ``pv-protection`` 파이널라이저를 추가한다.
``퍼시스턴트 볼륨``을 삭제하려 하면 ``Terminating`` 상태가 되지만 파이널라이저가 존재하기 때문에 컨트롤러가 삭제할 수 없다. 파드가 ``퍼시스턴트 볼륨``의 사용을 중지하면 쿠버네티스가 ``pv-protection`` 파이널 라이저를 해제하고 컨트롤러는 볼륨을 삭제한다.

==== 레이블
kubectl과 대시보드보다 더 많은 도구를 사용하여 쿠버네티스 객체를 시각화하고 관리할 수 있다. 공통 레이블 세트를 사용하면 도구들이 상호 운용 가능하게 작동하고, 모든 도구가 이해할 수 있는 공통된 방식으로 객체를 설명할 수 있다

===== 추천 레이블
.추천 라벨
[%autowidth,cols="1s,,a,"]
|===
|Key |Description |Example |Type

|app.kubernetes.io/name
|The name of the application
|mysql
|string

|app.kubernetes.io/instance
|A unique name identifying the instance of an application
|mysql-abcxyz
|string

|app.kubernetes.io/version
|The current version of the application (e.g., a SemVer 1.0, revision hash, etc.)
|5.7.21
|string

|app.kubernetes.io/component
|The component within the architecture
|database
|string

|app.kubernetes.io/part-of
|The name of a higher level application this one is part of
|wordpress
|string

|app.kubernetes.io/managed-by
|The tool being used to manage the operation of an application
|Helm
|string
|===

예)
[source,yaml]
----
# This is an excerpt
apiVersion: apps/v1
kind: StatefulSet
metadata:
  labels:
    app.kubernetes.io/name: mysql
    app.kubernetes.io/instance: mysql-abcxyz
    app.kubernetes.io/version: "5.7.21"
    app.kubernetes.io/component: database
    app.kubernetes.io/part-of: wordpress
    app.kubernetes.io/managed-by: Helm
----

[source,shell]
----
kubectl -n kube-system logs -l 'app.kubernetes.io/name=aws-ebs-csi-driver'
----

==== Pod
파드는 쿠버네티스에서 생성하고 관리할 수 있는 배포 가능한 가장 작은 컴퓨팅 단위이다.
파드는 하나 이상의 컨테이너 그룹이며, 이 그룹은 스토리지 및 네트워크를 공유하고, 해당 컨테이너를 구동하는 방식에 대한 명세를 갖는다.

파드는 자체적으로 자가 치유되지 않는다. 파드가 노드에 스케줄된 후에 해당 노드가 실패하면 파드는 삭제된다. 마찬가지로 파드는 리소스 부족 또는 노드 유지 관리 작업으로 인한 축출에서 살아남지 못한다.

===== 예시
[source,yaml]
----
apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
  - name: nginx
    image: nginx:1.14.2
    ports:
    - containerPort: 80
----

===== 프로브 종류
- livenessProbe : 컨테이너가 동작 중인지 여부를 나타낸다. liveness probe가 실패한다면, kubelet은 컨테이너를 죽이고, 해당 컨테이너는 재시작 정책 대상이 된다.
- readinessProbe : 컨테이너가 요청을 처리할 준비가 되었는지 여부를 나타낸다. 만약 readiness probe가 실패한다면, 엔드포인트 컨트롤러는 파드에 연관된 모든 서비스들의 엔드포인트에서 파드의 IP주소를 제거한다.
- startupProbe : 컨터에너 내의 애플리케이션이 시작되었는지를 나타낸다. startup probe가 주어진 경우, 성공할 때까지 다른 나머지 프로브는 활성화 되지 않는다. 만약 스타트업 프로브가 실패하면, kubelet이 컨테이너를 죽이고, 컨테이너는 재시작 정책에 따라 처리된다. ( 대량의 데이터 로딩, 구성 파일 또는 마이그레이션에 대한 작업 수행 )

==== 컨테이너 프로브 체크 종류
- exec : 컨테이너 내에서 지정된 명령어를 실행한다. 명령어가 상태 코드 0으로 종료되면 진단이 성공한 것으로 간주한다.
- grpc : gRPC를 사용하여 원격 프로시저 호출을 수행한다. 체크 대상이 gRPC 헬스 체크를 구현해야 한다.
- httpGet : 지정한 포트 및 경로에서 컨테이너의 IP주소에 대한 HTTP GET 요청을 수행한다. 응답의 상태 코드가 200이상 400미만이면 진단이 성공한 것으로 간주한다.
- tcpSocket : 지정된 포트에서 컨테이너의 IP주소에 대해 TCP 검사를 수행한다. 포트가 활성화되어 있다면 진단이 성공한 것으로 간주한다.

==== Pod Distruption Budgets
애플리케이션이 **동시에 겪는 중단 수를 제한하여 가용성을 높이는 방법**을 보여준다.

Kubernetes 서버는 버전 v1.21 이상이어야 한다.

===== 예시
https://kubernetes.io/ko/docs/concepts/workloads/pods/disruptions/#pdb-example

==== Deployment
여러 파드를 만들고 파드 장애 시 복제 및 롤아웃과 자동 복구를 처리한다.

상태를 유지하지 않습니다.

===== 사용 사례
- ReplicaSet을 롤아웃하기 위한 배포를 생성합니다.
- 배포의 PodTemplateSpec을 업데이트하여 Pod의 새 상태를 선업합니다.
- 배포의 현재 상태가 안정적이지 않은 경우 이전 배포 개정판으로 롤백합니다.
- 더 많은 부하를 처리할 수 있도록 배포를 확장합니다.
- PodTemplateSpec에 여러 수정 사항을 적용하기 위해 배포 롤아웃을 일시 중지한 다음 다시 시작하여 새로운 롤아웃을 시작합니다.
- 배포 상태를 롤아웃이 중단되었음을 나타내는 지표로 사용합니다.
- 더 이상 필요하지 않은 오래된 ReplicaSet를 정리합니다.

배포는 또한 원하는 Pod 수보다 일정 수의 Pod만 생성되도록 보장합니다. 기본적으로 원하는 Pod 수의 최대 125%(최대 25%)만 활성화되도록 합니다.

==== 예제
[source,shell]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80
----


=== 실습
==== deploy 배포
===== deployment에 nginx 버전 업그레이드

image::image/02_upgrade_deployment_exec.png[deployment에 nginx 버전 업그레이드]

==== 관련 명령어
[source,shell]
----
# 이미지 업데이트
kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1
# replicas 상태
kubectl get rs

# 롤아웃 기록 확인
kubectl rollout history deployment/nginx-deployment

# 이전 개정판으로 롤백
kubectl rollout undo deployment/nginx-deployment

# 배포 확장
kubectl scale deployment/nginx-deployment --replicas=10



----
==== DaemonSet
Unix/POSIX 서버의 시스템 데몬과 유사한 역할을 수행
- 예
